// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

static const int threadGroupSize = 128;

struct Boid
{
    float3 position;
    float3 forward;
    float3 raySteer;
    float steering;
};

float Angle(float3 f1, float3 f2)
{
    return acos(
        (f1.x * f2.x + f1.y * f2.y + f1.z * f2.z) / sqrt(pow(f1.x, 2) + pow(f1.y, 2) + pow(f1.z, 2)) * sqrt(
            pow(f2.x, 2) + pow(f2.y, 2) + pow(f2.z, 2)));
}

// Audio reactive values
float speedValueMin;
float speedValueMax;
bool useAudioBasedSpeed;
float speed;
float amplitudeBuffer;

// Boid values
int numBoids;
float noCompressionArea;
float localArea;
float repulsionArea;
float3 targetPointPos;
float3 repulsionPointPos;
float separationFactor;
float alignmentFactor;
float cohesionFactor;
float leadershipWeight;
float centerWeight;

// time value
float deltaTime;

RWStructuredBuffer<Boid> boid_bodies;

[numthreads(threadGroupSize,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //Initialisation of boids data on thread
    Boid boid_one = boid_bodies[id.x];

    const float3 origin = float3(0.0, 0.0, 0.0);

    float3 align_vector = origin;
    float3 sep_vector = origin;
    float3 coh_vector = origin;
    int separation_count = 1;
    int local_count = 1;

    float3 temp_steer = origin;
    float3 leaderSteering = origin;

    float leader_angle = 180.0;
    Boid leaderBoid = boid_one;

    //Validating BoidA against a new BoidB
    for (int indexB = 0; indexB < numBoids; indexB++)
    {
        //If BoidB doesn't equal BoidA
        if (indexB != int(id.x))
        {
            Boid boid_b = boid_bodies[indexB];

            //Checking how far away BoidB is from BoidA
            float3 neighbour_gap = boid_one.position - boid_b.position;
            float gap_length = length(neighbour_gap);

            //Separation
            if (gap_length < noCompressionArea)
            {
                sep_vector += neighbour_gap;
                separation_count++;
            }

            //Cohesion and Alignment
            if (gap_length < localArea)
            {
                align_vector += boid_b.forward;
                coh_vector += boid_b.position;
                local_count++;

                //Calculating a leader Boid
                float angle = Angle(boid_b.position - boid_one.position, boid_one.forward);
                if (angle < leader_angle && angle < 90.0)
                {
                    leaderBoid = boid_b;
                    leader_angle = angle;
                    temp_steer += normalize(leaderBoid.position - boid_one.position) * leadershipWeight;
                }
            }
        }
    }

    //Factoring neighbouring boid count into separation modifier
    if (separation_count > 1)
    {
        sep_vector /= separation_count;
    }

    //Factoring neighbouring boid count into cohesion and alignment modifier
    float avarage = 1.0 / local_count;
    align_vector *= avarage;
    coh_vector *= avarage;

    //Repulsion target calculation
    float boid_to_boid_rep = length(repulsionPointPos - boid_one.position);
    if (boid_to_boid_rep <= repulsionArea)
    {
        temp_steer -= repulsionPointPos - boid_one.position;
    }

    coh_vector = normalize(coh_vector - boid_one.position);

    //Adding them all to a steering value
    temp_steer += (sep_vector * separationFactor) +
        (align_vector * alignmentFactor) +
        (coh_vector * cohesionFactor) +
        ((targetPointPos - boid_one.position) * centerWeight);

    //Accounting for collisions from raycasts
    if (any(boid_one.raySteer))
    {
        temp_steer = boid_one.raySteer;
    }

    //Steering correction
    float steeringCorrection = exp(-boid_one.steering * deltaTime);

    //Steering boid
    boid_one.forward = lerp(temp_steer, normalize(boid_one.forward), steeringCorrection);

    //Moving boid
    if (useAudioBasedSpeed)
    {
        speed = lerp(speedValueMin, speedValueMax, amplitudeBuffer);
    }
    boid_one.position += boid_one.forward * (speed * deltaTime);

    //Updating boid position and rotation
    boid_bodies[id.x] = boid_one;
}
